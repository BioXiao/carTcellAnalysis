---
title: "P89 RNA-seq CAR transcript analysis"
author: "James Eddy"
date: "March 30, 2016"
output: html_document
---

```{r global_opts, echo=FALSE}
knitr::opts_chunk$set(fig.width=9, fig.align='center',
                      echo=FALSE, warning=FALSE, message=FALSE)

## numbers >= 10^5 will be denoted in scientific notation,
## and rounded to 2 digits
options(scipen = 1, digits = 2)
```

```{r load_packages}
library(knitr)
library(stringr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(viridis)
library(rtracklayer)
library(ggthemes)
library(scales)
library(cowplot)

myCbPal <- colorblind_pal()(8)
myCbPal[c(1, 3, 6)] <- myCbPal[c(6, 1, 3)]
myCbPal[3] <- "#666666"
```

## Overview

I compared **coverage profiles** and **estimated abundances** for *CAR* and
related transcripts using three sets of samples:

+ **P89 bulk:** sorted CD8+ T-cells, sequenced as bulk populations (expected
to express *CAR*)
+ **P89 single-cell:** CD8+ T-cells, captured using **C1** instrument and
sequenced invididually (expected to express *CAR*)
+ **P85 single-cell:** MAIT-cells, captured using **C1** and sequenced
individually (not expected to express *CAR*)

\  

## Getting the data

Data presented below was generated and/or compiled from several sources:

+ **`sample_metrics_data`:**  sample annotation (e.g., donor ID, timepoint, 
etc.) as well sequencing & alignment metrics from RNA-seq processing  
+ **`sample_rapmap_data`:** read coverage measured across the length of the
*CAR* transcript, based on mapping with the `RapMap` tool
+ **`sample_salmon_data`:** abundance estimates (e.g., TPM, count) produced
by the `Salmon` tool for *CAR* and several relevant transcripts when mapping to
a modified human reference transcriptome (hg38)
+ **`salmon_imgt_data`:** predicted/identified TCR junction sequences and
alleles in single-cell libraries, as produced by assembly with `Trinity` 
followed by matching with `IMGT High V-QUEST`
+ **`gff_file`:** custom-built GTF file describing where individual segments
are located along the length of the *CAR* transcript

```{r load_data, echo=TRUE}
load("data/sample_metrics_data.RData")
load("data/sample_rapmap_data.RData")
load("data/sample_salmon_data.RData")
load("data/sample_tcr_data.RData")

gff_file <- "data/annotation/carPlus.gtf"
xcripts_gtf <- import.gff2(gff_file)
```

```{r prep_gtf_dat}
xcript_dat <- as.data.frame(xcripts_gtf)

car_dat <- xcript_dat %>% 
    filter(seqnames == "CAR-1") %>% 
    mutate(segment = factor(transcript_id, levels = transcript_id))
```

```{r format_cov_dat}
# function to append CAR segment
get_segment <- Vectorize(function(pos) {
    xcript_dat %>% 
        filter(seqnames == "CAR-1",
               (start - 1) <= pos & (end + 1) >= pos) %>% 
        select(transcript_id) %>% 
        as.character()
})

lib_cov <- cov_dat %>% 
    filter(lib_id == cov_dat$lib_id[1]) %>% 
    mutate(segment = get_segment(pos)) %>% 
    select(pos, segment)

cov_dat <- cov_dat %>% 
    left_join(lib_cov, by = c("pos" = "pos")) %>% 
    filter(segment != "character(0)")
```


```{r data_clean_fxns}
# clean up duplicated headers
clean_dup_names <- function(df) {
    df_names <- names(df)
    is_dup_name <- duplicated(df_names)
    df_names[is_dup_name] <- str_c(df_names[is_dup_name], "2")
    names(df) <- df_names
    return(df)
}

# simplify library ID
simplify_lib_id <- function(df) {
    df_names <- names(df)
    is_lib_name <- str_detect(tolower(df_names), "lib.*id")
    df_names[is_lib_name] <- "lib_id"
    names(df) <- df_names
    
    df %>% 
        mutate(lib_id = str_extract(lib_id, "lib[0-9]+"))
}

# clean/relabel donor ID
clean_donor_ids <- function(df) {
    df %>% 
        mutate(donor_id = tolower(donor_id))
}

# relabel timepoints
relabel_timepoints <- function(df) {
    df %>% 
        mutate(timepoint = str_replace(timepoint, " ", ""),
               timepoint = str_replace(timepoint, "InfusionProduct", "IP"),
               timepoint = str_replace(timepoint, "Day0", "t0"),
               timepoint = str_replace(timepoint, "Day(7|8|9|12)", "t1"),
               timepoint = str_replace(timepoint, "Day(26|28|29|33)", "t2"))
}

# convert transcript names to segment names
relabel_transcripts <- function(df, xcript_dat) {
    df_names <- names(df)
    for (i in 1:length(df_names)) {
        if (df_names[i] %in% xcript_dat$seqnames) {
            xcript_row <- which(xcript_dat$seqnames %in% df_names[i])
            new_name <- xcript_dat$transcript_id[xcript_row]
            df_names[i] <- new_name
        }
    }
    names(df) <- df_names
    return(df)
}
```

```{r data_prep_fxn}
prep_cov_dat <- function(lib_dat, metric_dat) {
    lib_dat %>% 
        clean_dup_names() %>% 
        simplify_lib_id() %>%
        clean_donor_ids() %>% 
        select(lib_id, donor_id, timepoint) %>% 
        relabel_timepoints() %>% 
        left_join(cov_dat, by = c("lib_id" = "lib_id")) %>% 
        left_join(metric_dat %>% 
                      clean_dup_names() %>% 
                      simplify_lib_id() %>% 
                      select(lib_id, fastq_total_reads, 
                             median_cv_coverage, mapped_reads_w_dups),
                  by = c("lib_id" = "lib_id")) %>% 
        left_join(map_rate_dat, by = c("lib_id" = "lib_id")) %>% 
        mutate(mapped_reads = fastq_total_reads * map_rate,
               norm_cov = cov / mapped_reads) %>% 
        left_join(salmon_quant_dat %>% 
                      # filter(Name == "CAR-1") %>% 
                      select(lib_id, Name, TPM) %>% 
                      spread(Name, TPM) %>% 
                      dplyr::rename(CAR = `CAR-1`) %>% 
                      relabel_transcripts(xcript_dat)) %>% 
        left_join(jxn_summary_dat) %>% 
        mutate_each_(funs(. = ifelse(is.na(.), 0, .)), 
                     vars = c("tra_pos", "trb_pos", "tcr_pos"))
}
```

```{r plot_fxn}
plot_coverage <- function(formatted_cov_dat, gtf_dat, 
                          split = TRUE, fits_only = FALSE, 
                          color_by = "lib_num", fade_by = "log2(CAR + 1)",
                          hide_legend = FALSE) {
    
    # add lib numbers for coloring
    formatted_cov_dat <- formatted_cov_dat %>% 
        group_by(donor_id, timepoint) %>% 
        mutate(lib_num = dense_rank(lib_id) / n_distinct(lib_id),
               lib_num = as.character(lib_num)) %>% 
        ungroup()

    # determine plot height
    height <- log2(max(formatted_cov_dat$cov, na.rm = TRUE) + 1)
    
    # create color scale
    if (!fits_only) {
        gradient_stop <- myCbPal[3]
    } else {
        gradient_stop <- myCbPal[2]
    }
    num_libs <- n_distinct(formatted_cov_dat$lib_id)
    cc <- seq_gradient_pal(myCbPal[3], gradient_stop)(seq(0, 1, length.out = num_libs))
    
    # build plot
    p_cov <- ggplot() +
        geom_rect(data = gtf_dat, 
                  aes(xmin = start, xmax = end, ymin = 0, ymax = height, 
                      fill = segment),
                  alpha = 0.5, colour = "gray")
    if (!fits_only) {
        p_cov <- p_cov +
            geom_point(data = formatted_cov_dat, 
                       aes_string(x = "pos", y = "log2(cov + 1)", 
                                  alpha = fade_by, colour = color_by),
                       stroke = 0) +
            geom_smooth(data = formatted_cov_dat,
                        aes(x = pos, y = log2(cov + 1)),
                        se = FALSE, colour = myCbPal[2])
    } else {
        p_cov <- p_cov +
            geom_line(data = formatted_cov_dat,
                      aes_string(x = "pos", y = "log2(cov + 1)", 
                                 group = "lib_id", colour = color_by,
                                 alpha = fade_by),
                      stat = "smooth", method = "loess", 
                      se = FALSE, size = 1)
    }
    
    if (color_by == "lib_num") {
        p_cov <- p_cov + 
            scale_color_manual(values = cc) +
            guides(colour = FALSE)        
    } else {
        p_cov <- p_cov +
            scale_color_gradient(low = myCbPal[3], high = myCbPal[2])
    }
    
    if (is.numeric(fade_by)) {
        p_cov <- p_cov +
            scale_alpha_continuous(range = c(fade_by, fade_by)) +
            guides(alpha = FALSE)
    } else {
        p_cov <- p_cov +
            scale_alpha_continuous(range = c(0.2, 0.8))
    }
    
    if (color_by == fade_by) {
        p_cov <- p_cov +
            guides(alpha = FALSE)
    }

    p_cov <- p_cov +    
        scale_fill_viridis(discrete = TRUE) +
        theme_gray()
    
    if (split) {
        p_cov <- p_cov +
            facet_grid(donor_id ~ timepoint)
    }
    
    if (hide_legend) {
        p_cov <- p_cov +
            guides(fill = FALSE, colour = FALSE, alpha = FALSE)
    }
    return(p_cov)
}
```

\  

## Results

### Visualizing *CAR* coverage & abundance

The plots below show read coverage from `RapMap` mapping across the length of
the *CAR* sequence. Segments in the transcript, corresponding to the gene parts
used to build the construct, are depicted by colored boxes in each plot.
Transparency (i.e., alpha) is scaled based on the estimated abundance of the
*CAR* transcript (TPM) as measured by `Salmon`.

\  

#### Bulk libraries from project P89

```{r prep_bulk_cov_dat}
bulk_cov_dat <- bulk_lib_dat %>% 
    prep_cov_dat(bulk_metric_dat) %>% 
    filter(donor_id %in% c("x145", "x194", "x228"))
```

```{r plot_bulk_cov, fig.height=6}
plot_coverage(bulk_cov_dat, car_dat)
```

\  

#### Single-cell libraries from project P89

```{r prep_p89_c1_cov_dat}
p89_c1_cov_dat <- sc_lib_dat %>% 
    prep_cov_dat(sc_metric_dat)
```

```{r plot_p89_c1_cov, fig.height=6}
plot_coverage(p89_c1_cov_dat, car_dat)
```

\  

#### Single-cell libraries from project P85

```{r prep_p85_c1_cov_dat}
p85_c1_cov_dat <- p85_lib_dat %>% 
    prep_cov_dat(p85_metric_dat)
```

```{r plot_p85_c1_cov, fig.height=4}
plot_coverage(p85_c1_cov_dat, car_dat)
```

\  

### Inspecting trends in *CAR* coverage among single-cell P89 libs

To simplify the plots (and make it easier to distinguish between libraries),
I'll just plot the fitted line of coverage for each library.

```{r p89_cov_fits, fig.height=6}
p89_c1_cov_dat %>% 
    plot_coverage(car_dat, fits_only = TRUE)
```

\  

#### *CAR* coverage vs. QC pass/fail

> **pass:** `median_cv_coverage` < 1 **AND** `mapped_reads_w_dups` > 0.7

```{r p89_cov_qc, fig.height=3}
p89_c1_cov_dat %>% 
    mutate(pass_qual = ifelse(median_cv_coverage < 1 &
                                  mapped_reads_w_dups > 0.7, 
                              "pass_qc", "fail_qc")) %>% 
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_wrap(~ pass_qual)
```

\  

#### *CAR* coverage vs. presence of functional TCR junction

> **junction:** functional TRA **OR** TRB junction sequence detected

```{r p89_cov_jxn, fig.height=3}
p89_c1_cov_dat %>% 
    mutate(has_jxn = ifelse(tra_pos | trb_pos, 
                            "tra_or_trb", "no_jxn")) %>%
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_wrap(~ has_jxn)
```

\  

#### *CAR* coverage vs. presence of TCR (paired junction)

> **TCR:** paired TRA **AND** TRB for the same library

```{r p89_cov_tcr, fig.height=3}
p89_c1_cov_dat %>% 
    mutate(has_tcr = ifelse(tcr_pos, 
                            "tra_and_trb", "no_tcr")) %>%
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_wrap(~ has_tcr)
```

\  

### Inspecting abundance of non-*CAR* transcripts

```{r format_xcript_table}
xcript_id_table <- xcript_dat %>% 
    filter(seqnames != "CAR-1") %>% 
    select(xcript_name = gene_id, segment_version = transcript_id)
```

The following human transcripts (which overlap the *CAR* sequence) were 
quantified by `Salmon`.

`r kable(xcript_id_table)`

\  

Each plot shows *CAR* coverage across libraries, but colored based on the 
estimated abundance of the respective transcript.

```{r p89_all_segments_quant, fig.height=12, cache=TRUE}
gene_list <-c("CAR", 
      xcript_dat$transcript_id %>% intersect(names(p89_c1_cov_dat))) %>% 
    as.list()
p_list <- lapply(gene_list, function(x) {
    p <- p89_c1_cov_dat %>% 
        plot_coverage(car_dat, fits_only = TRUE, split = FALSE, 
                      hide_legend = TRUE, 
                      color_by = sprintf("log2(%s + 1)", x),
                      fade_by = sprintf("log2(%s + 1)", x))
    return(p)
})
plot_grid(plotlist = p_list, ncol = 3, nrow = 5, 
          labels = unlist(gene_list), hjust = 0)
```

\  
 
### Attempting to define *CAR* detection rules

I tried to come up with a relatively simple way to classify whether *CAR* was
detected in a particular library.

\  

#### Binarized *CAR* expression

> **expressed:** log2(TPM +1) $\gt$ 0 for *CAR* transcript

```{r p89_cov_car, fig.height=6}
car_expr_dat_tpm <- p89_c1_cov_dat %>% 
    mutate(car_expr_tpm = ifelse(log2(CAR + 1) > 0, 
                                 "car_expr_tpm", "no_car_tpm")) %>%
    group_by(lib_id) %>% 
    mutate(nz_cov = max(cov) >= 2) %>% 
    ungroup()

car_expr_dat_tpm %>% 
    filter(!is.na(nz_cov)) %>% 
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_grid(car_expr_tpm ~ nz_cov)

tally_tpm <- car_expr_dat_tpm %>% 
    group_by(car_expr_tpm, nz_cov) %>% 
    summarise(n_libs = n_distinct(lib_id))
```

`r kable(tally_tpm)`

\  

#### Quantification-based rule

> **expressed:** log2(TPM + 1) $\geq$ 2.5 in *CAR* or *EGFRt* transcripts **OR**
> log2(TPM + 1) $\gt$ 2 in all *CAR* or *EGFRt* transcripts

```{r p89_cov_quant_rule, fig.height=6}
quant_indicator_dat <- salmon_quant_dat %>% 
    select(lib_id, Name, TPM) %>% 
    spread(Name, TPM) %>% 
    dplyr::rename(CAR = `CAR-1`) %>% 
    relabel_transcripts(xcript_dat) %>%
    mutate_each(funs(log2(. + 1)), -lib_id) %>% 
    rowwise() %>% 
    mutate(car_expr_quant = ifelse(
        max(CAR, EGFRt_r1, EGFRt_r2, EGFRt_r3, EGFRt_r4, EGFRt_r5) >= 2.5 
        | min(CAR, EGFRt_r1, EGFRt_r2, EGFRt_r3, EGFRt_r4, EGFRt_r5) > 1,
        "car_expr_quant", "no_car_quant"))

car_expr_dat_quant <- p89_c1_cov_dat %>% 
    left_join(quant_indicator_dat %>% 
                  select(lib_id, car_expr_quant)) %>% 
    group_by(lib_id) %>% 
    mutate(nz_cov = max(cov) >= 2) %>% 
    ungroup()

car_expr_dat_quant %>% 
    filter(!is.na(nz_cov)) %>% 
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_grid(car_expr_quant ~ nz_cov)

tally_quant <- car_expr_dat_quant %>% 
    group_by(car_expr_quant, nz_cov) %>% 
    summarise(n_libs = n_distinct(lib_id))
```


`r kable(tally_quant)`

\  

#### Coverage-based rule

> **expressed:** $\geq$ 10 positions with $\gt$ 0 reads 
> in **ANY** of *CD19scFv*, *T2A*, or *EGFRt*

```{r p89_cov_cov_rule, fig.height=6}
cov_indicator_dat <- p89_c1_cov_dat %>% 
    group_by(lib_id, segment) %>% 
    filter(segment %in% c("CD19scFv", "T2A", "EGFRt")) %>% 
    summarise(hits = sum(cov > 0)) %>% 
    ungroup() %>% 
    group_by(lib_id) %>% 
    summarise(car_expr_cov = ifelse(any(hits >= 10),
                                    "car_expr_cov", "no_car_cov"))

car_expr_dat_cov <- p89_c1_cov_dat %>% 
    left_join(cov_indicator_dat %>% 
                  select(lib_id, car_expr_cov)) %>% 
    group_by(lib_id) %>% 
    mutate(nz_cov = max(cov) >= 2) %>% 
    ungroup()

car_expr_dat_cov %>% 
    filter(!is.na(nz_cov)) %>% 
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_grid(car_expr_cov ~ nz_cov)

tally_cov <- car_expr_dat_cov %>%  
    group_by(car_expr_cov, nz_cov) %>% 
    summarise(n_libs = n_distinct(lib_id))
```

`r kable(tally_cov)`

\  

### Revisiting trends

Plotting the remaining 53 libraries with *CAR* detected based on **coverage**.

\  

#### Timepoint vs. donor

```{r p89_cov_filtered}
car_expr_dat_cov %>% 
    filter(!is.na(nz_cov),
           car_expr_cov == "car_expr_cov") %>% 
    plot_coverage(car_dat, fits_only = TRUE, split = TRUE)
```

\  

#### Functional junction detection vs. *CAR* detection

```{r p89_cov_filtered_jxn, fig.height=3}
car_expr_dat_cov %>% 
    filter(!is.na(nz_cov)) %>% 
    mutate(has_jxn = ifelse(tra_pos | trb_pos, 
                            "tra_or_trb", "no_jxn")) %>%
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_grid(car_expr_cov ~ has_jxn)
```

\  

#### Paired TCR junction detection vs. *CAR* detection

```{r p89_cov_filtered_tcr, fig.height=3}
car_expr_dat_cov %>% 
    filter(!is.na(nz_cov)) %>% 
    mutate(has_tcr = ifelse(tcr_pos, 
                            "tra_and_trb", "no_tcr")) %>%
    plot_coverage(car_dat, fits_only = TRUE, split = FALSE) +
    facet_grid(car_expr_cov ~ has_tcr)
```

\  

## Session info

```{r session_info}
sessionInfo()
```